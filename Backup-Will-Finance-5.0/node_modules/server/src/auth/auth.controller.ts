import {
  Controller,
  Get,
  Post,
  Body,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import { AuthService } from './auth.service';
import { initializeFirebaseAdmin, admin } from '../config/firebase';

@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  @Post('register')
  @HttpCode(HttpStatus.CREATED)
  async register(@Body() body: any) {
    return this.authService.register(body);
  }

  /**
   * Endpoint para login social via Firebase (Google/Firebase Auth)
   * Recebe o idToken do Firebase, valida, busca/cria usuário, retorna JWT local
   */
  @Post('firebase-login')
  @HttpCode(HttpStatus.OK)
  async firebaseLogin(@Body() body: { idToken: string }) {
    initializeFirebaseAdmin();
    if (!body?.idToken) {
      return { success: false, message: 'idToken não fornecido' };
    }
    try {
      // Verifica e decodifica o token do Firebase
      const decoded = await admin.auth().verifyIdToken(body.idToken);
      // Busca/cria usuário no banco
      return await this.authService.firebaseLogin(decoded);
    } catch (error) {
      let errorMsg = 'Erro desconhecido';
      if (error && typeof error === 'object' && 'message' in error) {
        errorMsg = (error as { message?: string }).message ?? errorMsg;
      } else if (typeof error === 'string') {
        errorMsg = error;
      }
      return {
        success: false,
        message: 'Falha na autenticação Firebase',
        error: errorMsg,
      };
    }
  }

  @Post('login')
  @HttpCode(HttpStatus.OK)
  async login(@Body() body: any) {
    return this.authService.login(body);
  }

  @Get('profile')
  async getProfile() {
    await Promise.resolve(); // Força await para ESLint
    return { message: 'Profile endpoint' };
  }
}
